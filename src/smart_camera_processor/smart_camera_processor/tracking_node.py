import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import re
import json
from collections import defaultdict
import time
import cv2

class MultiCameraTrackingNode(Node):
    """
    ROS2 Node: Multi-Camera Object Tracking
    Nh·∫≠n detections t·ª´ YOLO v√† th·ª±c hi·ªán tracking qua nhi·ªÅu camera
    """
    def __init__(self):
        super().__init__('tracking_node')
        
        # Subscribe v√†o detections t·ª´ YOLO
        self.detections_subscription = self.create_subscription(
            String,
            '/processor/detections',
            self.detections_callback,
            10
        )
        
        # Dictionary ƒë·ªÉ l∆∞u camera subscriptions cho images
        self.camera_image_subscriptions = {}
        
        # Publisher cho tracking results
        self.tracking_publisher = self.create_publisher(String, '/processor/tracking', 10)
        
        # CV Bridge ƒë·ªÉ x·ª≠ l√Ω images
        self.bridge = CvBridge()
        
        # Tracking data structures
        self.camera_tracks = defaultdict(dict)  # {camera_id: {track_id: track_data}}
        self.global_track_id = 0
        self.track_history = defaultdict(list)  # {track_id: [positions]}
        
        # Timer ƒë·ªÉ discover camera image topics
        self.discovery_timer = self.create_timer(5.0, self.discover_camera_images)
        
        # Timer ƒë·ªÉ cleanup old tracks
        self.cleanup_timer = self.create_timer(10.0, self.cleanup_old_tracks)
        
        self.get_logger().info("‚úÖ Multi-Camera Tracking Node initialized")
        
        # Discover ngay l·∫≠p t·ª©c
        self.discover_camera_images()
    
    def discover_camera_images(self):
        """
        T·ª± ƒë·ªông t√¨m v√† subscribe v√†o t·∫•t c·∫£ camera image topics ƒë·ªÉ l·∫•y frames cho tracking
        """
        try:
            topic_names_and_types = self.get_topic_names_and_types()
            
            # Pattern ƒë·ªÉ match /camera/{id}/frames
            camera_pattern = re.compile(r'^/camera/([^/]+)/frames$')
            
            current_cameras = set()
            
            for topic_name, topic_types in topic_names_and_types:
                match = camera_pattern.match(topic_name)
                if match and 'sensor_msgs/msg/Image' in topic_types:
                    camera_id = match.group(1)
                    current_cameras.add(camera_id)
                    
                    # N·∫øu ch∆∞a subscribe th√¨ t·∫°o subscription m·ªõi
                    if camera_id not in self.camera_image_subscriptions:
                        self.create_image_subscription(camera_id, topic_name)
            
            # Cleanup c√°c subscription kh√¥ng c√≤n c·∫ßn thi·∫øt
            cameras_to_remove = set(self.camera_image_subscriptions.keys()) - current_cameras
            for camera_id in cameras_to_remove:
                self.remove_image_subscription(camera_id)
                
        except Exception as e:
            self.get_logger().error(f"Error in discover_camera_images: {e}")
    
    def create_image_subscription(self, camera_id: str, topic_name: str):
        """
        T·∫°o subscription cho camera images (ƒë·ªÉ tracking)
        """
        try:
            subscription = self.create_subscription(
                Image,
                topic_name,
                lambda msg, cid=camera_id: self.image_callback(msg, cid),
                10
            )
            
            self.camera_image_subscriptions[camera_id] = {
                'subscription': subscription,
                'last_frame': None,
                'frame_time': None
            }
            
            self.get_logger().info(f"üìπ Subscribed to camera images '{camera_id}' at {topic_name}")
            
        except Exception as e:
            self.get_logger().error(f"Failed to create image subscription for {camera_id}: {e}")
    
    def remove_image_subscription(self, camera_id: str):
        """
        X√≥a subscription cho camera kh√¥ng c√≤n ho·∫°t ƒë·ªông
        """
        if camera_id in self.camera_image_subscriptions:
            del self.camera_image_subscriptions[camera_id]
            # X√≥a tracks c·ªßa camera n√†y
            if camera_id in self.camera_tracks:
                del self.camera_tracks[camera_id]
            self.get_logger().info(f"üìπ Unsubscribed from camera images '{camera_id}'")
    
    def image_callback(self, msg: Image, camera_id: str):
        """
        Callback nh·∫≠n frames t·ª´ camera (ƒë·ªÉ tracking)
        """
        try:
            # L∆∞u frame m·ªõi nh·∫•t cho tracking
            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            
            self.camera_image_subscriptions[camera_id]['last_frame'] = cv_image
            self.camera_image_subscriptions[camera_id]['frame_time'] = time.time()
            
        except Exception as e:
            self.get_logger().error(f"Error processing image from camera {camera_id}: {e}")
    
    def detections_callback(self, msg: String):
        """
        Callback nh·∫≠n detections t·ª´ YOLO v√† th·ª±c hi·ªán tracking
        """
        try:
            detection_data = msg.data
            
            # Parse detection data: "[camera_id] object1:conf1,object2:conf2"
            if detection_data.startswith('['):
                # Multi-camera format
                match = re.match(r'\[([^\]]+)\]\s*(.+)', detection_data)
                if match:
                    camera_id = match.group(1)
                    detections_str = match.group(2)
                else:
                    self.get_logger().warn(f"Unable to parse detection format: {detection_data}")
                    return
            else:
                # Single camera format (backward compatibility)
                camera_id = "default"
                detections_str = detection_data
            
            # Parse individual detections
            detections = []
            if detections_str:
                for det in detections_str.split(','):
                    if ':' in det:
                        label, conf = det.split(':', 1)
                        detections.append({
                            'label': label.strip(),
                            'confidence': float(conf),
                            'camera_id': camera_id
                        })
            
            # Th·ª±c hi·ªán tracking
            tracked_objects = self.update_tracks(camera_id, detections)
            
            # Publish tracking results
            if tracked_objects:
                self.publish_tracking_results(camera_id, tracked_objects)
            
            self.get_logger().info(f"üéØ Camera {camera_id}: Tracking {len(tracked_objects)} objects")
            
        except Exception as e:
            self.get_logger().error(f"Error in detections_callback: {e}")
    
    def update_tracks(self, camera_id: str, detections: list) -> list:
        """
        C·∫≠p nh·∫≠t tracking cho camera (simplified tracking algorithm)
        """
        current_time = time.time()
        tracked_objects = []
        
        # L·∫•y frame hi·ªán t·∫°i n·∫øu c√≥
        current_frame = None
        if (camera_id in self.camera_image_subscriptions and 
            self.camera_image_subscriptions[camera_id]['last_frame'] is not None):
            current_frame = self.camera_image_subscriptions[camera_id]['last_frame']
        
        # Simplified tracking: assign track IDs based on object type and position
        for det in detections:
            # T√¨m track ph√π h·ª£p ho·∫∑c t·∫°o track m·ªõi
            track_id = self.assign_track_id(camera_id, det, current_time)
            
            track_data = {
                'track_id': track_id,
                'camera_id': camera_id,
                'label': det['label'],
                'confidence': det['confidence'],
                'timestamp': current_time,
                'frame_available': current_frame is not None
            }
            
            # L∆∞u v√†o camera tracks
            self.camera_tracks[camera_id][track_id] = track_data
            
            # L∆∞u v√†o history
            self.track_history[track_id].append({
                'camera_id': camera_id,
                'timestamp': current_time,
                'label': det['label']
            })
            
            tracked_objects.append(track_data)
        
        return tracked_objects
    
    def assign_track_id(self, camera_id: str, detection: dict, current_time: float) -> int:
        """
        Assign track ID cho detection (simplified algorithm)
        """
        # T√¨m track existing cho object type n√†y
        for track_id, track_data in self.camera_tracks[camera_id].items():
            if (track_data['label'] == detection['label'] and
                current_time - track_data['timestamp'] < 5.0):  # 5 seconds timeout
                return track_id
        
        # T·∫°o track m·ªõi
        self.global_track_id += 1
        return self.global_track_id
    
    def publish_tracking_results(self, camera_id: str, tracked_objects: list):
        """
        Publish tracking results
        """
        try:
            # Format: [camera_id] track_id1:label1:conf1,track_id2:label2:conf2
            tracking_data = []
            for obj in tracked_objects:
                tracking_data.append(f"{obj['track_id']}:{obj['label']}:{obj['confidence']:.2f}")
            
            if tracking_data:
                message = f"[{camera_id}] {','.join(tracking_data)}"
                self.tracking_publisher.publish(String(data=message))
        
        except Exception as e:
            self.get_logger().error(f"Error publishing tracking results: {e}")
    
    def cleanup_old_tracks(self):
        """
        X√≥a c√°c tracks c≈© kh√¥ng c√≤n ho·∫°t ƒë·ªông
        """
        current_time = time.time()
        timeout = 10.0  # 10 seconds
        
        for camera_id in list(self.camera_tracks.keys()):
            tracks_to_remove = []
            
            for track_id, track_data in self.camera_tracks[camera_id].items():
                if current_time - track_data['timestamp'] > timeout:
                    tracks_to_remove.append(track_id)
            
            # X√≥a old tracks
            for track_id in tracks_to_remove:
                del self.camera_tracks[camera_id][track_id]
                self.get_logger().info(f"üßπ Cleaned up old track {track_id} from camera {camera_id}")
    
    def get_tracking_stats(self) -> dict:
        """
        L·∫•y th·ªëng k√™ tracking
        """
        stats = {
            'total_cameras': len(self.camera_tracks),
            'active_tracks': sum(len(tracks) for tracks in self.camera_tracks.values()),
            'track_history_size': len(self.track_history)
        }
        return stats

def main(args=None):
    rclpy.init(args=args)
    node = MultiCameraTrackingNode()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        # In th·ªëng k√™ cu·ªëi
        stats = node.get_tracking_stats()
        node.get_logger().info(f"üìä Final stats: {stats}")
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()